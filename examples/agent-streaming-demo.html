<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Streaming & Visualization Demo</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f7fa;
        }
        
        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .query-section {
            margin-bottom: 30px;
        }
        
        .query-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 15px;
            resize: vertical;
            min-height: 100px;
        }
        
        .query-input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        
        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-primary {
            background: #3498db;
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background: #2980b9;
            transform: translateY(-1px);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .progress-section {
            margin-bottom: 20px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e1e8ed;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .status {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }
        
        .events-log {
            background: #f8f9fa;
            border: 1px solid #e1e8ed;
            border-radius: 8px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .event-entry {
            margin-bottom: 8px;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .event-info { background: #e3f2fd; }
        .event-success { background: #e8f5e8; }
        .event-warning { background: #fff3cd; }
        .event-error { background: #f8d7da; }
        
        .response-section {
            margin-top: 20px;
        }
        
        .response-text {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        /* Markdown content styling */
        .response-text h1, .response-text h2, .response-text h3, 
        .response-text h4, .response-text h5, .response-text h6 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            color: #2c3e50;
        }
        
        .response-text h1 { font-size: 1.5em; border-bottom: 2px solid #3498db; padding-bottom: 0.3em; }
        .response-text h2 { font-size: 1.3em; border-bottom: 1px solid #bdc3c7; padding-bottom: 0.2em; }
        .response-text h3 { font-size: 1.1em; color: #34495e; }
        
        .response-text ul, .response-text ol {
            margin: 1em 0;
            padding-left: 2em;
        }
        
        .response-text li {
            margin-bottom: 0.5em;
        }
        
        .response-text p {
            margin: 1em 0;
        }
        
        .response-text code {
            background: #f1f2f6;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9em;
            color: #e74c3c;
        }
        
        .response-text pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1em;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1em 0;
        }
        
        .response-text pre code {
            background: none;
            color: inherit;
            padding: 0;
        }
        
        .response-text blockquote {
            border-left: 4px solid #3498db;
            margin: 1em 0;
            padding-left: 1em;
            color: #666;
            font-style: italic;
        }
        
        .response-text table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }
        
        .response-text th, .response-text td {
            border: 1px solid #ddd;
            padding: 0.5em;
            text-align: left;
        }
        
        .response-text th {
            background: #f8f9fa;
            font-weight: 600;
        }
        
        .response-text strong {
            color: #2c3e50;
            font-weight: 600;
        }
        
        .response-text em {
            color: #7f8c8d;
        }
        
        .response-text a {
            color: #3498db;
            text-decoration: none;
        }
        
        .response-text a:hover {
            text-decoration: underline;
        }
        
        .chart-container {
            background: white;
            border: 1px solid #e1e8ed;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            min-height: 400px;
        }
        
        .sample-queries {
            margin-top: 20px;
        }
        
        .sample-query {
            background: #f8f9fa;
            border: 1px solid #e1e8ed;
            border-radius: 6px;
            padding: 10px 15px;
            margin: 5px 0;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
        }
        
        .sample-query:hover {
            background: #e9ecef;
            border-color: #3498db;
        }
        
        .hidden {
            display: none;
        }
        
        .cypher-query {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            margin: 10px 0;
            overflow-x: auto;
        }
        
        .visualization-info {
            background: #e8f5e8;
            border: 1px solid #d4edda;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .timestamp {
            color: #666;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ Agent Streaming & Visualization Demo</h1>
            <p>Experience real-time query processing with automatic chart generation</p>
        </div>
        
        <div class="query-section">
            <textarea 
                id="queryInput" 
                class="query-input" 
                placeholder="Ask a question about your conversation data...&#10;&#10;Examples:&#10;‚Ä¢ How many conversations do we have in total?&#10;‚Ä¢ Show me the NPS distribution&#10;‚Ä¢ What are the top conversation categories?&#10;‚Ä¢ Show me conversation trends over time"
            ></textarea>
            
            <div class="controls">
                <button id="submitBtn" class="btn btn-primary">üöÄ Submit Query</button>
                <button id="stopBtn" class="btn" disabled>‚èπÔ∏è Stop</button>
                <button id="debugBtn" class="btn">üîß Test Visualization</button>
                
                <div class="checkbox-container">
                    <input type="checkbox" id="visualizationEnabled" checked>
                    <label for="visualizationEnabled">Enable Visualization</label>
                </div>
                
                <div class="checkbox-container">
                    <input type="checkbox" id="showEvents">
                    <label for="showEvents">Show Events Log</label>
                </div>
            </div>
        </div>
        
        <div class="sample-queries">
            <h3>üìù Sample Queries</h3>
            <div class="sample-query" onclick="useQuery('How many conversations do we have in total?')">
                How many conversations do we have in total?
            </div>
            <div class="sample-query" onclick="useQuery('Show me the NPS distribution')">
                Show me the NPS distribution
            </div>
            <div class="sample-query" onclick="useQuery('What are the top 10 conversation categories?')">
                What are the top 10 conversation categories?
            </div>
            <div class="sample-query" onclick="useQuery('How many resolved vs unresolved conversations?')">
                How many resolved vs unresolved conversations?
            </div>
            <div class="sample-query" onclick="useQuery('Show me conversation trends over the last 30 days')">
                Show me conversation trends over the last 30 days
            </div>
            <div class="sample-query" onclick="useQuery('What are the busiest hours for conversations?')">
                What are the busiest hours for conversations?
            </div>
            <div class="sample-query" onclick="useQuery('Show me the hierarchical structure of conversation categories with counts')">
                üå≥ Show me the hierarchical structure of conversation categories with counts
            </div>
        </div>
    </div>
    
    <div class="container progress-section hidden" id="progressSection">
        <h3>‚ö° Processing Status</h3>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="status" id="statusText">Ready to process query...</div>
        
        <div class="events-log hidden" id="eventsLog">
            <strong>üì° Events Stream:</strong>
            <div id="eventsContainer"></div>
        </div>
    </div>
    
    <div class="container response-section hidden" id="responseSection">
        <h3>üí¨ Agent Response</h3>
        <div class="response-text" id="responseText"></div>
        
        <div class="hidden" id="cypherSection">
            <h4>üîç Generated Query</h4>
            <div class="cypher-query" id="cypherQuery"></div>
            <p><em id="cypherExplanation"></em></p>
        </div>
        
        <div class="hidden" id="visualizationSection">
            <h4>üìä Visualization</h4>
            <div class="visualization-info" id="visualizationInfo"></div>
            <div class="chart-container" id="chartContainer"></div>
        </div>
    </div>
    
    <script>
        // Configuration
        const API_BASE = 'http://localhost:8080/api/v1/agent';
        
        // DOM elements
        const queryInput = document.getElementById('queryInput');
        const submitBtn = document.getElementById('submitBtn');
        const stopBtn = document.getElementById('stopBtn');
        const debugBtn = document.getElementById('debugBtn');
        const visualizationEnabled = document.getElementById('visualizationEnabled');
        const showEvents = document.getElementById('showEvents');
        const progressSection = document.getElementById('progressSection');
        const progressFill = document.getElementById('progressFill');
        const statusText = document.getElementById('statusText');
        const eventsLog = document.getElementById('eventsLog');
        const eventsContainer = document.getElementById('eventsContainer');
        const responseSection = document.getElementById('responseSection');
        const responseText = document.getElementById('responseText');
        const cypherSection = document.getElementById('cypherSection');
        const cypherQuery = document.getElementById('cypherQuery');
        const cypherExplanation = document.getElementById('cypherExplanation');
        const visualizationSection = document.getElementById('visualizationSection');
        const visualizationInfo = document.getElementById('visualizationInfo');
        const chartContainer = document.getElementById('chartContainer');
        
        let currentAbortController = null;
        
        // Configure marked for safe rendering
        marked.setOptions({
            breaks: true,
            gfm: true,
            sanitize: false, // We control the content source
            highlight: function(code, language) {
                // Basic syntax highlighting placeholder
                return code;
            }
        });
        
        // Helper function to render markdown safely
        function renderMarkdown(markdownText) {
            try {
                return marked.parse(markdownText);
            } catch (e) {
                console.warn('Error parsing markdown:', e);
                // Fallback to plain text with line breaks
                return markdownText.replace(/\n/g, '<br>');
            }
        }
        
        // Event handlers
        submitBtn.addEventListener('click', submitQuery);
        stopBtn.addEventListener('click', stopQuery);
        debugBtn.addEventListener('click', testVisualization);
        showEvents.addEventListener('change', toggleEventsLog);
        
        queryInput.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                submitQuery();
            }
        });
        
        function useQuery(query) {
            queryInput.value = query;
            queryInput.focus();
        }
        
        async function testVisualization() {
            try {
                addEvent('info', 'Testing visualization endpoint...');
                updateStatus('üîß Testing visualization...');
                
                const response = await fetch(`${API_BASE}/query/stream`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                addEvent('success', 'Visualization test completed', result);
                
                if (result.visualization) {
                    // Show the visualization
                    visualizationSection.classList.remove('hidden');
                    responseSection.classList.remove('hidden');
                    
                    visualizationInfo.innerHTML = `
                        <strong>Chart Type:</strong> ${result.visualization.chartType}<br>
                        <strong>Title:</strong> ${result.visualization.title}<br>
                        <strong>Description:</strong> ${result.visualization.description}
                    `;
                    
                    responseText.innerHTML = renderMarkdown('Debug visualization test completed successfully. This shows that the visualization service is working properly.');
                    
                    try {
                        Plotly.newPlot('chartContainer', result.visualization.data, result.visualization.layout, result.visualization.config);
                        updateStatus('‚úÖ Visualization test successful!');
                    } catch (error) {
                        addEvent('error', 'Failed to render test chart', error.message);
                        updateStatus('‚ùå Chart rendering failed');
                    }
                } else {
                    updateStatus('‚ö†Ô∏è No visualization generated in test');
                    addEvent('warning', 'Test completed but no visualization was generated', result);
                }
                
            } catch (error) {
                console.error('Visualization test error:', error);
                addEvent('error', `Visualization test failed: ${error.message}`);
                updateStatus(`‚ùå Test failed: ${error.message}`);
            }
        }
        
        function toggleEventsLog() {
            eventsLog.classList.toggle('hidden', !showEvents.checked);
        }
        
        function submitQuery() {
            const query = queryInput.value.trim();
            if (!query) {
                alert('Please enter a query');
                return;
            }
            
            resetUI();
            startStreaming(query);
        }
        
        function stopQuery() {
            if (currentAbortController) {
                currentAbortController.abort();
                currentAbortController = null;
                updateStatus('‚ùå Query stopped by user');
                resetButtons();
                addEvent('warning', 'Query stopped by user');
            }
        }
        
        function resetUI() {
            progressSection.classList.remove('hidden');
            responseSection.classList.add('hidden');
            cypherSection.classList.add('hidden');
            visualizationSection.classList.add('hidden');
            eventsContainer.innerHTML = '';
            updateProgress(0);
            updateStatus('üöÄ Starting query...');
            
            submitBtn.disabled = true;
            stopBtn.disabled = false;
        }
        
        function resetButtons() {
            submitBtn.disabled = false;
            stopBtn.disabled = true;
        }
        
        function updateProgress(percentage) {
            progressFill.style.width = `${percentage * 100}%`;
        }
        
        function updateStatus(status) {
            statusText.textContent = status;
        }
        
        function addEvent(type, message, data = null) {
            if (!showEvents.checked) return;
            
            const eventEntry = document.createElement('div');
            eventEntry.className = `event-entry event-${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            eventEntry.innerHTML = `
                <span class="timestamp">[${timestamp}]</span> 
                <strong>${type.toUpperCase()}:</strong> ${message}
                ${data ? `<br><small>${JSON.stringify(data, null, 2)}</small>` : ''}
            `;
            
            eventsContainer.appendChild(eventEntry);
            eventsContainer.scrollTop = eventsContainer.scrollHeight;
        }
        
        function startStreaming(query) {
            const requestBody = {
                query: query,
                includeContext: true,
                maxRetries: 2,
                enableVisualization: visualizationEnabled.checked
            };
            
            // Use fetch with ReadableStream to handle Server-Sent Events
            realStreaming(requestBody);
        }
        
        async function realStreaming(requestBody) {
            try {
                addEvent('info', 'Starting real API call', requestBody);
                
                // Create AbortController for cancellation support
                currentAbortController = new AbortController();
                
                const response = await fetch(`${API_BASE}/query/stream`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody),
                    signal: currentAbortController.signal
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    
                    // Process complete SSE messages (ending with double newline)
                    let doubleNewlineIndex;
                    while ((doubleNewlineIndex = buffer.indexOf('\n\n')) !== -1) {
                        const eventBlock = buffer.substring(0, doubleNewlineIndex);
                        buffer = buffer.substring(doubleNewlineIndex + 2);
                        
                        if (eventBlock.trim()) {
                            try {
                                const lines = eventBlock.split('\n');
                                let eventId = null;
                                let eventType = null;
                                let eventData = null;
                                
                                for (const line of lines) {
                                    if (line.startsWith('id:')) {
                                        eventId = line.substring(3).trim();
                                    } else if (line.startsWith('event:')) {
                                        eventType = line.substring(6).trim();
                                    } else if (line.startsWith('data:')) {
                                        eventData = line.substring(5).trim();
                                    }
                                }
                                
                                if (eventData) {
                                    const parsedData = JSON.parse(eventData);
                                    console.log('SSE Event:', eventType, '(id:', eventId + ')', parsedData);
                                    handleRealStreamEvent(parsedData);
                                }
                            } catch (e) {
                                console.warn('Failed to parse SSE event:', eventBlock, e);
                            }
                        }
                    }
                }
                
                currentAbortController = null;
                resetButtons();
                
            } catch (error) {
                currentAbortController = null;
                
                if (error.name === 'AbortError') {
                    // Query was cancelled by user
                    console.log('Query cancelled by user');
                    return;
                }
                
                console.error('Streaming error:', error);
                addEvent('error', `API call failed: ${error.message}`);
                updateStatus(`‚ùå Error: ${error.message}`);
                resetButtons();
            }
        }
        
        function handleRealStreamEvent(eventData) {
            const eventType = eventData.type;
            console.log('Processing event:', eventType, eventData);
            
            // Update progress based on event type
            const progressMap = {
                'query_started': 0.1,
                'context_building': 0.2,
                'cypher_generation': 0.3,
                'cypher_generated': 0.4,
                'query_execution': 0.5,
                'query_executed': 0.6,
                'natural_language_generation': 0.7,
                'visualization_generation': 0.8,
                'visualization_generated': 0.9,
                'progress': eventData.progress || 0.5,
                'complete': 1.0
            };
            
            // Use explicit progress from event if available, otherwise use mapped value
            const progress = eventData.progress !== undefined ? eventData.progress : progressMap[eventType];
            if (progress !== undefined) {
                updateProgress(progress);
                console.log('Updated progress to:', progress);
            }
            
            // Update status based on event type
            let statusMessage = null;
            
            switch (eventType) {
                case 'query_started':
                    statusMessage = 'üöÄ Query started';
                    break;
                case 'context_building':
                    statusMessage = eventData.message || 'üîç Building graph context...';
                    break;
                case 'cypher_generation':
                    statusMessage = eventData.status || '‚öôÔ∏è Generating Cypher query...';
                    break;
                case 'cypher_generated':
                    statusMessage = '‚úÖ Cypher query generated';
                    break;
                case 'query_execution':
                    statusMessage = 'üóÑÔ∏è Executing query...';
                    break;
                case 'query_executed':
                    statusMessage = '‚úÖ Query executed successfully';
                    break;
                case 'natural_language_generation':
                    statusMessage = eventData.status || 'üí¨ Generating response...';
                    break;
                case 'natural_language_generated':
                    statusMessage = 'üí¨ Response ready!';
                    break;
                case 'visualization_generation':
                    statusMessage = eventData.status || 'üìä Creating visualization...';
                    break;
                case 'visualization_generated':
                    statusMessage = '‚úÖ Chart generated';
                    break;
                case 'complete':
                    statusMessage = 'üéâ Complete!';
                    break;
                case 'error':
                    statusMessage = `‚ùå Error: ${eventData.error || 'Unknown error'}`;
                    break;
                case 'progress':
                    statusMessage = eventData.details || eventData.currentStep || 'Processing...';
                    break;
                case 'query_retry':
                    statusMessage = `üîÑ Retrying query (${eventData.attempt}/${eventData.maxRetries})...`;
                    break;
                default:
                    statusMessage = `Processing ${eventType}...`;
            }
            
            if (statusMessage) {
                updateStatus(statusMessage);
                addEvent('info', statusMessage);
                console.log('Updated status:', statusMessage);
            }
            
            // Handle specific event types
            switch (eventType) {
                case 'cypher_generated':
                    if (eventData.cypherQuery) {
                        cypherQuery.textContent = eventData.cypherQuery;
                        cypherExplanation.textContent = eventData.explanation || '';
                        cypherSection.classList.remove('hidden');
                        addEvent('success', 'Cypher query generated', { query: eventData.cypherQuery });
                    }
                    break;
                    
                case 'natural_language_generated':
                case 'response_ready':
                    // Show natural language response as soon as it's available
                    if (eventData.naturalLanguageResponse || eventData.response) {
                        const response = eventData.naturalLanguageResponse || eventData.response;
                        responseText.innerHTML = renderMarkdown(response);
                        responseSection.classList.remove('hidden');
                        addEvent('success', 'Natural language response ready');
                    }
                    break;
                    
                case 'partial_response':
                    // Handle incremental response updates
                    if (eventData.partialResponse) {
                        responseText.innerHTML = renderMarkdown(eventData.partialResponse);
                        responseSection.classList.remove('hidden');
                        addEvent('info', 'Response updated');
                    }
                    break;
                    
                case 'visualization_generated':
                    if (eventData.chartType) {
                        visualizationInfo.innerHTML = `
                            <strong>Chart Type:</strong> ${eventData.chartType}<br>
                            <strong>Title:</strong> ${eventData.title || 'Data Visualization'}<br>
                            <strong>Description:</strong> ${eventData.description || 'Interactive chart showing data insights'}
                        `;
                        addEvent('success', 'Visualization ready', { chartType: eventData.chartType });
                    }
                    break;
                    
                case 'complete':
                    // Handle final completion - response may already be shown
                    if (eventData.response) {
                        // Only update response if it's different or not already shown
                        if (eventData.response.naturalLanguageResponse && 
                            responseText.textContent !== eventData.response.naturalLanguageResponse) {
                            responseText.innerHTML = renderMarkdown(eventData.response.naturalLanguageResponse);
                            responseSection.classList.remove('hidden');
                        }
                        
                        // Handle visualization if available
                        if (eventData.response.visualization && visualizationEnabled.checked) {
                            const viz = eventData.response.visualization;
                            visualizationSection.classList.remove('hidden');
                            
                            try {
                                Plotly.newPlot('chartContainer', viz.data, viz.layout, viz.config);
                                addEvent('success', 'Chart rendered successfully');
                            } catch (error) {
                                addEvent('error', 'Failed to render chart', error.message);
                            }
                        }
                        
                        addEvent('success', 'Query completed successfully');
                    }
                    resetButtons();
                    break;
                    
                case 'error':
                    addEvent('error', eventData.error || 'Unknown error occurred');
                    resetButtons();
                    break;
                    
                case 'query_retry':
                    addEvent('warning', `Retrying query (attempt ${eventData.attempt}/${eventData.maxRetries}): ${eventData.error}`);
                    break;
            }
        }
        
        // Keep the simulation function for fallback/demo purposes
        function simulateStreaming(requestBody) {
            addEvent('info', 'Starting simulated streaming (fallback mode)', requestBody);
            
            const events = [
                { type: 'query_started', delay: 100, progress: 0.1, status: 'üöÄ Query started' },
                { type: 'context_building', delay: 500, progress: 0.2, status: 'üîç Building graph context...' },
                { type: 'cypher_generation', delay: 1000, progress: 0.4, status: '‚öôÔ∏è Generating Cypher query...' },
                { type: 'cypher_generated', delay: 1500, progress: 0.5, status: '‚úÖ Cypher query generated' },
                { type: 'query_execution', delay: 2000, progress: 0.6, status: 'üóÑÔ∏è Executing query...' },
                { type: 'query_executed', delay: 2500, progress: 0.7, status: '‚úÖ Query executed successfully' },
                { type: 'natural_language_generation', delay: 3000, progress: 0.8, status: 'üí¨ Generating response...' },
                { type: 'natural_language_generated', delay: 3200, progress: 0.85, status: 'üí¨ Response ready!' },
                { type: 'visualization_generation', delay: 3500, progress: 0.9, status: 'üìä Creating visualization...' },
                { type: 'visualization_generated', delay: 4000, progress: 0.95, status: '‚úÖ Chart generated' },
                { type: 'complete', delay: 4500, progress: 1.0, status: 'üéâ Complete!' }
            ];
            
            events.forEach((event, index) => {
                setTimeout(() => {
                    updateProgress(event.progress);
                    updateStatus(event.status);
                    addEvent('info', event.status);
                    
                    handleStreamEvent(event.type, {
                        query: requestBody.query,
                        progress: event.progress,
                        cypherQuery: "MATCH (c:Conversation) RETURN count(c) as total",
                        explanation: "This query counts all conversations in the database",
                        chartType: "BAR",
                        title: "Sample Visualization",
                        response: {
                            naturalLanguageResponse: "Based on the analysis, you have 1,247 conversations in your system. This represents all conversations that have been processed and stored in the graph database.",
                            visualization: {
                                chartType: "BAR",
                                title: "Conversation Categories",
                                description: "Distribution of conversations by category",
                                data: [{
                                    type: 'bar',
                                    x: ['Technical Support', 'Billing', 'Feature Request', 'Bug Report', 'General Inquiry'],
                                    y: [450, 320, 280, 150, 97],
                                    marker: {
                                        color: ['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6']
                                    }
                                }],
                                layout: {
                                    title: 'Top Conversation Categories',
                                    xaxis: { title: 'Category' },
                                    yaxis: { title: 'Number of Conversations' },
                                    showlegend: false,
                                    font: { family: 'Arial, sans-serif' }
                                },
                                config: {
                                    responsive: true,
                                    displayModeBar: true
                                }
                            }
                        }
                    });
                    
                    if (event.type === 'complete') {
                        resetButtons();
                    }
                }, event.delay);
            });
        }
        
        function handleStreamEvent(eventType, data) {
            switch (eventType) {
                case 'cypher_generated':
                    cypherQuery.textContent = data.cypherQuery;
                    cypherExplanation.textContent = data.explanation;
                    cypherSection.classList.remove('hidden');
                    addEvent('success', 'Cypher query generated', { query: data.cypherQuery });
                    break;
                    
                case 'natural_language_generated':
                    // Show natural language response as soon as it's available
                    responseText.innerHTML = renderMarkdown(data.response.naturalLanguageResponse);
                    responseSection.classList.remove('hidden');
                    addEvent('success', 'Natural language response ready');
                    break;
                    
                case 'visualization_generated':
                    visualizationInfo.innerHTML = `
                        <strong>Chart Type:</strong> ${data.chartType}<br>
                        <strong>Title:</strong> ${data.title}<br>
                        <strong>Description:</strong> ${data.description || 'Interactive chart showing data insights'}
                    `;
                    addEvent('success', 'Visualization ready', { chartType: data.chartType });
                    break;
                    
                case 'complete':
                    // Response may already be shown, just handle visualization and final cleanup
                    if (!responseSection.classList.contains('hidden')) {
                        // Response already shown, just finalize
                        addEvent('info', 'Response was already displayed earlier');
                    } else {
                        // Fallback in case response wasn't shown earlier
                        responseText.innerHTML = renderMarkdown(data.response.naturalLanguageResponse);
                        responseSection.classList.remove('hidden');
                    }
                    
                    if (data.response.visualization && visualizationEnabled.checked) {
                        const viz = data.response.visualization;
                        visualizationSection.classList.remove('hidden');
                        
                        try {
                            Plotly.newPlot('chartContainer', viz.data, viz.layout, viz.config);
                            addEvent('success', 'Chart rendered successfully');
                        } catch (error) {
                            addEvent('error', 'Failed to render chart', error.message);
                        }
                    }
                    
                    addEvent('success', 'Query completed successfully');
                    break;
            }
        }
        
        // Initialize
        toggleEventsLog();
        
        // Add some sample data on load for demonstration
        window.addEventListener('load', () => {
            console.log('ü§ñ Agent Streaming Demo loaded - REAL API MODE');
            console.log('üí° Tips:');
            console.log('  - Use Ctrl+Enter to submit queries quickly');
            console.log('  - Enable "Show Events Log" to see detailed processing steps');
            console.log('  - Toggle visualization on/off to compare experiences');
            console.log('  - Use "Test Visualization" button to debug visualization issues');
            console.log('  - Make sure your API key is configured and the backend is running');
            console.log(`  - API Base URL: ${API_BASE}`);
        });
    </script>
</body>
</html> 
